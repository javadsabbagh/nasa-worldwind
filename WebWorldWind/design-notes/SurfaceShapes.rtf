{\rtf1\ansi\ansicpg1252\cocoartf1344\cocoasubrtf720
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww21540\viewh21500\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs28 \cf0 2/4/15\
\

\fs36 Overview
\fs28 \
\
Surface shapes provide World Wind applications with the capability to display primitive shapes overlaid on the World Wind terrain. Although surface shapes provide a set of primitives similar in name to 3D primitive shapes, surface shapes solve the problem of displaying geometry that appears to follow the surface of the terrain exactly, and with a clear edge displayed at the shape\'92s boundaries. Said another way, surface shapes are infinitely thin primitives draped over the terrain. Though surface shapes follow the terrain, surface shapes that cross the anti-meridian or contains a poles are displayed correctly. World Wind provides the following surface shapes: SurfacePolygon, SurfacePolyline, SurfaceEllipse, SurfaceCircle, SurfaceQuad, SurfaceSquare and SurfaceSector.\
\
Surface shapes may be attached to any layer in a World Window, and are configured by the application. SurfacePolygon and SurfacePolyline are configured with a list of locations and a path type. SurfacePolygon may contain multiple lists of locations, in which case regions of non-zero winding order identify the interior regions. A shape\'92s locations must be re-specified by the application in order for a shape to update its display; changes to any of the location\'92s values are not automatically reflected in a shape\'92s display. The path type indicates the method of interpolating between locations: great circle, rhumb or linear. SurfacePolygon and SurfacePolyline implicitly tessellate between the application-specified locations in order to give the appearance of following a great circle or a rhumb line.\
\
SurfaceEllipse, SurfaceCircle, SurfaceQuad and SurfaceSquare are configured with a center point and one or more dimensions in meters. These shapes implicitly compute their boundaries based on the center location and the given dimensions. Each dimension indicates the length in meters of a great arc between the center location and the edge indicated by the dimension. For example, an ellipse\'92s major radius indicates the length in meters of the great arc between the center location and a location on the end of either major axis. A shape\'92s center location or dimensions must be re-specified in order for a shape to update its display; changes to the center location are not automatically reflected in a shape\'92s display. Though the meaning of path type is less clear for these shapes, they implicitly tessellate between their implicitly generated locations in order to give the appearance of following a great circle or a rhumb line.\
\
SurfaceSector is configured with an axis-aligned rectangle in geographic coordinates. A SurfaceSector\'92s rectangle must be re-specified in order for a shape to update its display; changes to the rectangle is not automatically reflected in the shape\'92s display. Though the meaning of path type is less clear SurfaceSector, this shape implicitly tessellates between it\'92s implicitly generated locations in order to give the appearance of following a great circle or a rhumb line. \
\

\fs36 Implementation in World Wind Java
\fs28 \
\
Surface shapes are drawn into a per-WorldWindow collection of off-screen texture tiles in an equirectangular projection. These tiles are selected as a function of the viewer\'92s position and orientation and are independent of the shapes themselves. Only those tiles intersecting a shape are displayed each frame.\
\
Surface Shapes in World Wind Java use OpenGL to rasterize themselves into the off-screen textures. This enabled surface shapes to display textures and line stippling patterns using the same GL state as their 3D counterparts, and produced a similar visual effect. Additionally, offscreen rendering using AWT was found to be slower than GL rendering. The off-screen texture tiles typically have the same dimension, but vary in the geographic region they represent. In this way, texture tiles of progressively finer resolution can be selected, and enable surface shapes to maintain an approximately constant ration of texels to screen pixels.  \
\
World Wind Java limits its use of OpenGL to version 1.4 in order to support older hardware, and therefore cannot assume the availability of framebuffer objects for offscreen rendering. For this reason, surface shapes are drawn into a texture tile sized region of the World Window\'92s framebuffer then copied into the texture tile. GL framebuffer objects are used on platforms supporting that extension, but the overall code path does not change. World Wind Java defines three rendering phases: preRender, pick, and render. Surface shape offscreen rendering occurs during the preRender phase during which a renderable is given full control of the framebuffer.\
\
The WorldWindow\'92s SceneController, DrawContext and SurfaceObjectTileBuilder work together each frame to create a single set of texture tiles that contain a visual representation of all surface shapes. The following six steps outline that process:\
\
1) The SceneController calls preRender on each layer. Any surface shapes in the layers add themselves to the SceneController\'92s queue of surface shapes using a method on the DrawContext: addOrderedSurfaceRenderable.\
2) After calling preRendering on all layers, the SceneController enables its ordered rendering flag, then passes its queue of surface shapes to a SurfaceObjectTileBuilder.\
3) SurfaceObjectTileBuilder assembles its texture tiles based on the current eye point and frustum, determines which shapes intersect each tile.\
4) SurfaceObjectTileBuilder updates each tile as necessary. Tiles are updated when one of the following conditions is true: (a) the tile\'92s texture is not in the GPU resource cache, (b) the list of intersecting shapes has changed since the last update, or (c) any shape\'92s state has changed since the last update.\
5) For all tiles that must be updated, SurfaceObjectTileBuilder clears the tile texture, then draws all intersecting surface shapes into the tile by calling render on each shape. Since the SceneController is in ordered rendering mode, surface shapes use this as an indicator to draw themselves. The texture tile\'92s dimensions and geographic bounds are available during surface shape rendering via a property of the DrawContext.  \
6) After calling render on all layers, the SceneController draws the SurfaceObjectTileBuilder\'92s texture tiles on the current terrain tiles. \
\
During picking, the fragments of each shape must be displayed in a unique color. The texture tiles containing the visual representation of all surface shapes are not suitable of this purpose, since it\'92s unclear which shape contributed to each telex. Surface shapes display their pick representation by working with SurfaceObjectTileBuilder to maintain a set of texture tiles containing the shape\'92s texels in white. During picking, these texture tiles are modulated with a unique pick color and drawn on the terrain.\
\
1) The SceneController calls preRender on each layer. Each surface shapes intersecting the pick frustum enables picking and ordered rendering (temporarily), then passes itself to an internal SurfaceObjectTileBuilder.\
2) SurfaceObjectTileBuilder assembles its texture tiles based on the current eye point and frustum, determines which tiles the shape intersects.\
3) For all tiles that must be updated, SurfaceObjectTileBuilder clears the tile texture, then draws the shapes into the tile by calling render. Since the SceneController is in picking mode and ordered rendering mode, the surface shape uses this as an indicator to draw its pick representation. The texture tile\'92s dimensions and geographic bounds are available during surface shape rendering via a property of the DrawContext.  \
6) During layer picking, each surface shape draws its pick tiles on the terrain, modulating the texture fragments with the current pick color.\
\
A surface shape\'92s locations may define a complex polygon, whether specified explicitly or computed implicitly. Two examples are a polygon with holes, or an ellipse with concave geometry in the equirectangular projection. Surface shape\'92s use the GLU tessellation to triangulate their locations. The output of this step is a list of triangle indices that display the shape\'92s interior, and a list of line segment indices that display the shape\'92s outline.\
\

\fs36 Porting from World Wind Java to Web World Wind
\fs28 \
\
The port of surface shapes from World Wind Java to Web World Wind will be a direct port of the current design and implementation, with the following exceptions:\
\
1) Store shape vertices and indices in GL buffers instead of submitting them using immediate mode GL calls (e.g. glBegin/glVertex/glEnd). \
\
2) Replace GL 1.x style state changes with uniform properties of GL 2.x shaders.\
\
In World Wind Java, surface shapes use the GLU tessellation to triangulate their geometry every time they render, and submit vertices during the triangulation using immediate mode GL calls. The design assumption guiding this choice was that the texture tiles cache the shape representation, so the tessellation indices need not be kept around. This has proven to be a false assumption, and updates to surface shape texture tiles can be expensive as a result. Since the port requires replacing immediate mode GL calls, take the opportunity to keep the tessellated indices around, rather than recomputing them.\
}